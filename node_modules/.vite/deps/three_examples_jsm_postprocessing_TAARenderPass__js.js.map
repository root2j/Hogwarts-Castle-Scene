{
  "version": 3,
  "sources": ["../../three/examples/jsm/postprocessing/SSAARenderPass.js", "../../three/examples/jsm/postprocessing/TAARenderPass.js"],
  "sourcesContent": ["import {\n\tAdditiveBlending,\n\tColor,\n\tLinearFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n*\n* Supersample Anti-Aliasing Render Pass\n*\n* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n*\n* References: https://en.wikipedia.org/wiki/Supersampling\n*\n*/\n\nclass SSAARenderPass extends Pass {\n\n\tconstructor( scene, camera, clearColor, clearAlpha ) {\n\n\t\tsuper();\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\t\tthis.unbiased = true;\n\n\t\t// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\t\tthis.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;\n\t\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\t\tthis._oldClearColor = new Color();\n\n\t\tif ( CopyShader === undefined ) console.error( 'THREE.SSAARenderPass relies on CopyShader' );\n\n\t\tconst copyShader = CopyShader;\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.copyMaterial = new ShaderMaterial(\t{\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tpremultipliedAlpha: true,\n\t\t\ttransparent: true,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tthis.fsQuad = new FullScreenQuad( this.copyMaterial );\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.sampleRenderTarget ) {\n\n\t\t\tthis.sampleRenderTarget.dispose();\n\t\t\tthis.sampleRenderTarget = null;\n\n\t\t}\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tif ( this.sampleRenderTarget )\tthis.sampleRenderTarget.setSize( width, height );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer ) {\n\n\t\tif ( ! this.sampleRenderTarget ) {\n\n\t\t\tthis.sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat } );\n\t\t\tthis.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n\n\t\t}\n\n\t\tconst jitterOffsets = _JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];\n\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tconst oldClearAlpha = renderer.getClearAlpha();\n\n\t\tconst baseSampleWeight = 1.0 / jitterOffsets.length;\n\t\tconst roundingRange = 1 / 32;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.sampleRenderTarget.texture;\n\n\t\tconst width = readBuffer.width, height = readBuffer.height;\n\n\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\tfor ( let i = 0; i < jitterOffsets.length; i ++ ) {\n\n\t\t\tconst jitterOffset = jitterOffsets[ i ];\n\n\t\t\tif ( this.camera.setViewOffset ) {\n\n\t\t\t\tthis.camera.setViewOffset( width, height,\n\t\t\t\t\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\t\twidth, height );\n\n\t\t\t}\n\n\t\t\tlet sampleWeight = baseSampleWeight;\n\n\t\t\tif ( this.unbiased ) {\n\n\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\n\t\t\t\t// across a range of values whose rounding errors cancel each other out.\n\n\t\t\t\tconst uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );\n\t\t\t\tsampleWeight += roundingRange * uniformCenteredDistribution;\n\n\t\t\t}\n\n\t\t\tthis.copyUniforms[ 'opacity' ].value = sampleWeight;\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\t\t\trenderer.setRenderTarget( this.sampleRenderTarget );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\trenderer.setRenderTarget( this.renderToScreen ? null : writeBuffer );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.clear();\n\n\t\t\t}\n\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\tif ( this.camera.clearViewOffset ) this.camera.clearViewOffset();\n\n\t\trenderer.autoClear = autoClear;\n\t\trenderer.setClearColor( this._oldClearColor, oldClearAlpha );\n\n\t}\n\n}\n\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nconst _JitterVectors = [\n\t[\n\t\t[ 0, 0 ]\n\t],\n\t[\n\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t],\n\t[\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t],\n\t[\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t],\n\t[\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t],\n\t[\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t]\n];\n\nexport { SSAARenderPass };\n", "import {\n\tWebGLRenderTarget\n} from 'three';\nimport { SSAARenderPass } from '../postprocessing/SSAARenderPass.js';\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nclass TAARenderPass extends SSAARenderPass {\n\n\tconstructor( scene, camera, clearColor, clearAlpha ) {\n\n\t\tsuper( scene, camera, clearColor, clearAlpha );\n\n\t\tthis.sampleLevel = 0;\n\t\tthis.accumulate = false;\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime ) {\n\n\t\tif ( ! this.accumulate ) {\n\n\t\t\tsuper.render( renderer, writeBuffer, readBuffer, deltaTime );\n\n\t\t\tthis.accumulateIndex = - 1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst jitterOffsets = _JitterVectors[ 5 ];\n\n\t\tif ( ! this.sampleRenderTarget ) {\n\n\t\t\tthis.sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );\n\t\t\tthis.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n\n\t\t}\n\n\t\tif ( ! this.holdRenderTarget ) {\n\n\t\t\tthis.holdRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );\n\t\t\tthis.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n\n\t\t}\n\n\t\tif ( this.accumulate && this.accumulateIndex === - 1 ) {\n\n\t\t\tsuper.render( renderer, this.holdRenderTarget, readBuffer, deltaTime );\n\n\t\t\tthis.accumulateIndex = 0;\n\n\t\t}\n\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tconst sampleWeight = 1.0 / ( jitterOffsets.length );\n\n\t\tif ( this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length ) {\n\n\t\t\tthis.copyUniforms[ 'opacity' ].value = sampleWeight;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = writeBuffer.texture;\n\n\t\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\t\tconst numSamplesPerFrame = Math.pow( 2, this.sampleLevel );\n\t\t\tfor ( let i = 0; i < numSamplesPerFrame; i ++ ) {\n\n\t\t\t\tconst j = this.accumulateIndex;\n\t\t\t\tconst jitterOffset = jitterOffsets[ j ];\n\n\t\t\t\tif ( this.camera.setViewOffset ) {\n\n\t\t\t\t\tthis.camera.setViewOffset( readBuffer.width, readBuffer.height,\n\t\t\t\t\t\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\t\t\treadBuffer.width, readBuffer.height );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t\trenderer.setRenderTarget( this.sampleRenderTarget );\n\t\t\t\tif ( this.accumulateIndex === 0 ) renderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\tthis.accumulateIndex ++;\n\n\t\t\t\tif ( this.accumulateIndex >= jitterOffsets.length ) break;\n\n\t\t\t}\n\n\t\t\tif ( this.camera.clearViewOffset ) this.camera.clearViewOffset();\n\n\t\t}\n\n\t\tconst accumulationWeight = this.accumulateIndex * sampleWeight;\n\n\t\tif ( accumulationWeight > 0 ) {\n\n\t\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.sampleRenderTarget.texture;\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\tif ( accumulationWeight < 1.0 ) {\n\n\t\t\tthis.copyUniforms[ 'opacity' ].value = 1.0 - accumulationWeight;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.holdRenderTarget.texture;\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\tif ( accumulationWeight === 0 ) renderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n}\n\nconst _JitterVectors = [\n\t[\n\t\t[ 0, 0 ]\n\t],\n\t[\n\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t],\n\t[\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t],\n\t[\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t],\n\t[\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t],\n\t[\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t]\n];\n\nexport { TAARenderPass };\n"],
  "mappings": "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",
  "names": ["_JitterVectors"]
}
